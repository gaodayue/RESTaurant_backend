{
  "name": "cansecurity",
  "description": "cansecurity is your all-in-one security library for user authentication, authorization and management in node expressjs apps",
  "version": "0.6.10",
  "url": "http://github.com/deitch/cansecurity",
  "author": {
    "name": "Avi Deitcher",
    "email": "avi@deitcher.net"
  },
  "engines": [
    "node >= 0.3"
  ],
  "main": "./lib/index.js",
  "dependencies": {
    "lodash": ">=1.3.1",
    "async": "0.2.x",
    "express": ">=2.0.0"
  },
  "devDependencies": {
    "express": "3.x",
    "mocha": "1.x",
    "supertest": "0.x"
  },
  "keywords": [
    "security",
    "node",
    "nodejs",
    "express",
    "cansecurity",
    "authentication",
    "authorization",
    "declarative"
  ],
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/deitch/cansecurity.git"
  },
  "readme": "# cansecurity\n\n## Overview\ncansecurity is your **all-in-one** security library for user authentication management and authorization in node (and specifically expressjs) apps.\n\nYou can use use authentication, per-route authorization, and even <u>declarative</u> authorization. You can authenticate against *any* authentication system you like, just provide the interface function.\n\nIt's this simple:\n    \n    var express = require('express'), app = express(), cs = require('cansecurity'), cansec = cs.init(/* init params */);\n\t\tapp.use(cansec.validate);\n\t\tapp.user(app.router);\n\t\t\n\t\t// send200 is a shortcut route to send a 200 response\n\t\t\n\t\t// open route\n\t\tapp.get(\"/public\",send200);\n\t\t\n\t\t// only authorized if logged in, or as certain roles, or some combination\n\t\tapp.get(\"/secure/loggedin\",cansec.restrictToLoggedIn,send200);\n\t\tapp.get(\"/secure/user/:user\",cansec.restrictToSelf,send200);\n\t\tapp.get(\"/secure/roles/admin\",cansec.restrictToRoles(\"admin\"),send200);\n\t\tapp.get(\"/secure/roles/adminOrSuper\",cansec.restrictToRoles([\"admin\",\"super\"]),send200);\n\t\tapp.get(\"/secure/selfOrRoles/:user/admin\",cansec.restrictToSelfOrRoles(\"admin\"),send200);\n\t\tapp.get(\"/secure/selfOrRoles/:user/adminOrSuper\",cansec.restrictToSelfOrRoles([\"admin\",\"super\"]),send200);\n\t\t\n\t\t// only authorized if \"searchParam\" is set to the same value as the user ID field set in cs.init();\n\t\tapp.get(\"/secure/param\",cansec.restrictToParam(\"searchParam\"),send200);\n\t\tapp.get(\"/secure/paramOrRole\",cansec.restrictToParamOrRoles(\"searchParam\",\"admin\"),send200);\n\t\tapp.get(\"/secure/paramOrMultipleRoles\",cansec.restrictToParamOrRoles(\"searchParam\",[\"admin\",\"super\"]),send200);\n\t\t\n\t\t// only authorized if getCheckObject() returns an object, with field owner, that has a value matching the user ID field\n\t\tapp.get(\"/secure/field\",cansec.restrictToField(\"owner\",getCheckObject),send200);\n\t\tapp.get(\"/secure/fields\",cansec.restrictToField([\"owner\",\"recipient\"],getCheckObject),send200);\n\t\tapp.get(\"/secure/fieldOrRole\",cansec.restrictToFieldOrRoles(\"owner\",\"admin\",getCheckObject),send200);\n\t\tapp.get(\"/secure/fieldOrRoles\",cansec.restrictToFieldOrRoles(\"owner\",[\"admin\",\"super\"],getCheckObject),send200);\n\t\tapp.get(\"/secure/fieldsOrRole\",cansec.restrictToFieldOrRoles([\"owner\",\"recipient\"],\"admin\",getCheckObject),send200);\n\t\tapp.get(\"/secure/fieldsOrRoles\",cansec.restrictToFieldOrRoles([\"owner\",\"recipient\"],[\"admin\",\"super\"],getCheckObject),send200);\n\t\t\n\t\t// only authorized if the request parameter \"private\" has the value \"true\", and then restrict to logged in\n\t\tapp.get(\"/secure/conditionalDirect\",cansec.ifParam(\"private\",\"true\").restrictToLoggedIn,send200);\n\t\tapp.get(\"/secure/conditionalIndirect\",cansec.ifParam(\"private\",\"true\").restrictToRoles([\"admin\",\"super\"]),send200);\n\n\nAnd if you prefer declarative authorization, even easier:\n\n    // inside app.js:\n\t\t\n\t\t// instantiate the user validator\n\t\tapp.use(cansec.validate);\n    // instantiate the declarative authorizer\n\t\tapp.use(cansec.authorizer(pathToAuthConfigFile));\n\t\t\n\t\t// inside \"pathToAuthConfigFile\"\n\t\t{\n\t\t\t\"routes\": [\n\t\t\t  // [verb,path,default,[test params,] test condition]\n\t\t\t\t[\"GET\",\"/api/user\",\"user.roles.admin === true\"],\n\t\t\t\t[\"GET\",\"/api/user/:user\",\"user.roles.admin === true || user.id === req.param('user')\"],\n\t\t\t\t[\"GET\",\"/api/user/:user\",{\"private\":\"true\"},\"user.roles.admin === true || user.id === req.param('user')\"],\n\t\t\t\t[\"PUT\",\"/api/user/:user\",\"user.roles.admin === true || user.id === req.param('user')\"],\n\t\t\t\t[\"GET\",\"/api/user/:user/roles\",\"user.roles.admin === true || user.id === req.param('user')\"],\n\t\t\t\t[\"PUT\",\"/api/user/:user/roles\",\"user.roles.admin === true\"]\n\t\t\t]\t\n\t\t}\n\t\t\n\n\n#### Changes\nFor any breaking changes, please see the end of this README.\n\n### Authentication\ncansecurity will manage your user authentication, including managing stateless sessions. It can use either native express sessions and or its own **stateless** sessions. cansecurity stateless sessions can keep a user logged in automatically across multiple nodejs instances, essentially creating free single-sign-on.\n\n### Authorization\ncansecurity will handle authorization in your requests, determining if a user should be allowed to perform a certain request, based on your rules. \n\nYou can tell cansecurity to manage your authorization imperatively (via middleware code) or declaratively (using a config file). Whatever works better for you is just fine for cansecurity!\n\n## Installation\nInstallation is simple, just install the npm module:\n\n    npm install cansecurity\n\n\n## Authentication\n### Usage\nFirst *initialize* your cansecurity instance, then use its *validation* to validate users.\n\n#### Initialization\nTo initialize cansecurity, you must first require() it, and then init() it, which will return the middleware you can use:\n\n````JavaScript\nvar cs = require('cansecurity');\nvar cansec = cs.init(initConfig);\n````\n\nThe `initConfig` has four properties:\n\n* `sessionExpiry`: OPTIONAL. Integer in minutes how long sessions should last, default is `15`. Used both for expressjs sessions and CS sessions. Setting `sessionExpiry` will **only** affect how long a session is valid **for cansecurity**. It will **not** affect the underlying expressjs session itself.\n* `sessionKey`: OPTIONAL. String. Secret key shared between nodejs servers to provide single-sign-on. This is a string. The default, if none is provided, is a random 64-character string. This is **required** if you want to take advantage of cansecurity's stateless sessions. Keep this very secret.\n* `validate`: REQUIRED. Function that will get a user by username, and possibly validate a their password, asynchronously. For more details, see below.\n\n#### Validation\nValidation is straightforward. Once you have set up cansecurity properly, it functions as standard expressjs middleware:\n\n    app.use(cansec.validate);\n\t\tapp.use(app.router);\n\nThis should be done **before** your router.\n\nIf the user is successfully authenticated, then the user object will be placed in two locations:\n\n    req[\"X-CS-Auth\"];\n    req.session[\"X-CS-AUTH\"].user;  // only if expressjs sessions have been enabled\n\nHowever, for safety, you should retrieve it using the convenience method:\n\n````JavaScript\nrequire('cansecurity').getUser(req);\n// or simply\ncs.getUser(req);\n````\n\nYou can also determine *how* the current user was authorized, credentials (e.g. password) and token, by calling \n\n````JavaScript\nrequire('cansecurity').getAuthMethod(req);\n// returns \"credentials\" or \"token\"\n// or simply\ncs.getAuthMethod(req);\n````\n\nThis is very useful in cases when you need the existing password for an action. A common use case is changing a password or setting security parameters. You might be fine with the user logging in via token for most actions (happens all the time when you go back to Facebook or Twitter from the same browser as last time), but if they want to change their password, they need to send the password again (try changing your Facebook or Gmail password, or Gmail two-factor autnentication).\n\n\n### Required Options\nThe **only** required option to `cs.init()` is the function to allow cansecurity to get a user from your system: `validate()`.\n\nMust have the following signature\n\n    validate(username,password,callback);\n\nThe `validate()` function is expected to retrieve user information from your preferred user store. It *may* validate a password for the user as well, and indicate to the callback if it succeeded or failed. The signature and expected parameters to the callback are as follows:\n\n    callback(success,user,message,pass);\n\nWhere:\n  `success`: boolean, if we succeeded in retrieving the user and, if requested, validating password credentials\n\t`user` = the actual user object. This can be a function, a JavaScript object, anything you want. It will be placed inside the session and the request for you to use later. If retrieval/validation was successful, this must not be null/undefined.\n\t`message` = the error message in case of retrieval/validation failure. This can be anything you want, and will be passed along with the 401 unauthenticated response. \n\t`pass` = the user's password or any other unique per-user string, not easily guessable. Commonly, this would be a hash of a password.\n\nIf the user was already authenticated via session, token or some other method, then `validateUser()` will be called with `password` parameter set to `undefined`. If `password` is set to **anything** other than `undefined` (including a blank string), then `validateUser()` is expected to validate the password along with retrieving the user.\n\n````JavaScript\ncansec.init({\n\tvalidate: function(username,password,callback) {\n\t\tif (password !== undefined) {\n\t\t\t// validate the username and password, then retrieve the user credentials\n\t\t} else {\n\t\t\t// just retrieve the user credentials\n\t\t}\n\t}\n});\n````\n\n### Unauthenticated Errors\nWhen authnetication fails, cansecurity will directly return 401 with the message \"unauthenticated\". \n\n* If authentication is required and succeeds, it will set request[\"X-CS-Auth\"], and request.session[\"X-CS-Auth\"] if sessions are enabled, and then call next() to jump to the next middleware. \n* If authentication is required and fails, it will return `401` with the text message `unauthenticated`\n* If authentication is **not** required, it will jump to the next middleware \n\nIf the user has provided HTTP Basic Authentication credentials in the form of username/password **and** the authentication via `validate()` fails. In that case, cansecurity will call \n\n\n### Why We Need the \"Password\" in the Validate() Callback\nThe callback to `validate()` expects you to return a \"pass\", or any user-unique string. Although this is never given to any other function, let alone to the client, why is the \"pass\" necessary? \n\nIn reality, this can be any unique string at all, as long as it is consistent for the same user. Normally, this would be a hashed password. This is used, along with the secret session key, to create the authtoken for cansecurity sessions. Without using the password or some other unique, non-guessable string, it would be theoretically possible to use one login to spoof another. With the unique non-guessable user string (hashed password or similar) as part of the hash input, this risk is mitigated. PLEASE *PLEASE* **PLEASE** do not pass cleartext passwords here. In reality, your app should never know cleartext passwords, rather storing them as SHA1 or similar hashes. \n\nThus, to create a unique authentication token that is useful for single-sign-on and cannot be spoofed to another user, we include the unique user string (e.g. a hashed password) as part of the input to the authentication token.\n\n### How Authentication Works\nWith each request, the following algorithm is followed:\n\n1. Was there an HTTP Basic authentication header? If so, validate using the credentials. If they succeed, the user is authenticated, else send back a 401 unauthenticated and include a response X-CS-Auth header of \"error=invalidpass\". If not, go to the next step.\n2. Was there an X-CS-Auth header? If so, validate using the auth header. If they success, the user is authenticated, else they are not. The requests will continue, but the response will contain an X-CS-Auth header of \"error=invalidtoken\". If not, go to the next step.\n3. Is there a valid and non-expired expressjs session? If so, the user is authenticated. If not, go to the next step.\n4. The user is not authenticated.\n\nNote that failing to get an authentication for all of the above steps does **not** necessarily indicate that a 401 should be sent back. It is entirely possible that the user is accessing a resource that does not require authentication! This part of the cansecurity library is entirely about authentication; authorization is a different topic.\n\n### HTTP Response Headers\ncansecurity passes details about success or failure of authentication in custom `X-` HTTP response headers. Of course, a failed authentication will return a `401`, but the *reason* for failure will be in the appropriate header listed in this section. Similarly, a successful authentication - by *any* means - will allow the request to go through returning a `200`, `201`, `404`, etc., depending on the app. cansecurity will, however, return the session token and logged in user via appropriate HTTP response headers.\n\n#### X-CS-Auth Header\nThe X-CS-Auth response header contains error responses or success tokens. If authentication was successful, by any means, then a new header is generated with each request. This header is of the following format:\n\n    success=sha1hash:username:expiry\n\nWhere:\n\t`sha1hash` = a sha1 hash of the username, the expiry, the secret session key and the user's unique string (likely itself a hashed password).\n\t`username` = the user's username\n\t`expiry` = when this auth token will expire, as a JavaScript (Unix) millisecond timestamp, provided by Date().getTime().\n\t\nEssentially, we are using a message validation algorithm to validate that the username and expiry are, indeed, valid.\n\nBecause the auth header is created anew with each request, the expiry window is rolling - x minutes from the last valid request.\n\n#### X-CS-User Header\nThe X-CS-User response header contains the actual logged in user when authentication by any means was successful. Normally, it is a JSON-encoded string, but it really depends on what your `validate()` function returns in the `user` parameter of the `callback`.\n\n#### CORS\nNote for usage in CORS situations. cansecurity automatically adds the following header to every response:\n\n    Access-Control-Expose-Headers: X-CS-Auth,X-CS-User\n\nOf course, it does so intelligently, so it adds it to an existing list of headers (does not trounce them) or creates it.\n\n### Performance\nExtensive performance testing has not been done. However, all of the algorithms are symmetric, which are very high-performance. The expensive part is validate(), which may require your app to look in a data source or database. However, since the majority of requests will simply hit the local session, the user will be stored locally, and it is not an issue. The hit will only be for the first authentication for each user, as well as when a user switches between nodejs servers using cansecurity stateless sessions.\n\n### Example\nFor a good example, see the test suite in test/test.js, specifically the section beginning cansec.init. It is reproduced below:\n\n```JavaScript\nvar express = require('express'), app = express(), cs = require('cansecurity'), cansec,\n// static database for testing\nuser = {name:\"john\",pass:\"1234\",age:25};\n\ncansec = cs.init({\n\tvalidate: function(login,password,callback){\n\t\tif (user.name !== login) {\n\t\t\t// no such user - ERROR\n\t\t\tcallback(false,null,\"invaliduser\");\n\t\t} else if (password === undefined) {\n\t\t\t// never asked to check a password, just send the user - GOOD\n\t    callback(true,user,user.name,shaHash(pass));\n\t\t} else if (user.pass !== pass) {\n\t\t\t// asked to check password, but it didn't match - ERROR\n\t\t\tcallback(false,null,\"invalidpass\");\n\t\t} else {\n\t\t\t// user matches, password matches - GOOD\n\t\t\tcallback(true,user,user.name,shaHash(pass));\n\t\t}\n\t},\n\tsessionKey: SESSIONKEY\n});\n\n\napp.configure(function(){\n\tapp.use(express.cookieParser());\t\n\tapp.use(express.session({secret: \"agf67dchkQ!\"}));\n\tapp.use(cansec.validate);\n\tapp.use(function(req,res,next){\n\t\t// send a 200\n\t\tsendResponse(req,res,200);\n\t});\n});\napp.user(function(err,req,res,next){\n\tvar data;\n\tif (err && err.status) {\n\t\t// one of ours\n\t\tdata = err.message ? {message: err.message} : null;\n\t\tsendResponse(req,res,err.status,data);\n\t} else if (err && err.type && err.type === \"unexpected_token\") {\n\t\t// malformed data\n\t\tsendResponse(req,res,{message:err.type},400);\n\t} else {\n\t\tsendResponse(req,res,500);\n\t}\n\t\n});\napp.listen(PORT);\n```\n\n## Authorization\nAuthorization is the process of checking if a user is **allowed** to perform a certain action (in our case, execute a certain route), assuming they have already been authenticated (or not).\n\ncansecurity can do authorization as route-specific middleware (imperative) or via a config file (declarative).\n\ncansecurity authorization also includes conditionals, allowing the authorization to be applied only if certain parameters are met.\n\n### Middleware Authorization\nThis is the traditional express usage: declare a route, chain up some middleware functions. The easiest way to demonstrate this is with an example, following which we will describe all of the options and APIs.\n\n````JavaScript\nexpress = require('express'),\ncansec = require('cansecurity').init({});\nserver = express.createServer();\n// do lots of server initialization\napp.get(\"/some/route/:user\",cansec.restrictToLoggedIn,routeHandler);\napp.get(\"/some/route\",cansec.ifParam(\"private\",\"true\").restrictToRoles(\"admin\"),routeHandler);\n\n````\n\n#### Usage\nUsage of cansecurity authorization is only possible if you are using cansecurity authentication as well. To use authorization, you do two steps: initialization and middleware.\n\n##### Initialization\nThe authorization component of cansecurity is initialized at the same time as the authentication component:\n\n````JavaScript\nvar cs = require('cansecurity'), cansec;\ncansec = cs.init({});\n````\n\nor more simply:\n\n````JavaScript\nvar cansec = require('cansecurity').init({});\n````\n\nIn initialization, you set two key authorization parameters as properties of the config object passed to cs.init(). Both are objects and both are optional.\n\n* fields: OPTIONAL. Fields within the User object that was retrieved/set during authentication. These fields are expected to be part of a POJSO (Plain Old JavaScript Object) stored as part of validate(), and are used in some of the restrictTo* authorization middleware. There are currently two fields:\n* * fields.id: Property of the User object that contains the user ID. OPTIONAL. Defaults to \"id\"\n* * fields.roles: Property of the User object that contains the user roles, as an array of strings. OPTIONAL. Defaults to \"roles\"\n* params: OPTIONAL. Names of params passed as part of the expressjs route, and retrievable as this.params[param]. These params are used as part in some of the restrictTo* authorization middleware. There is currently one field:\n* * params.id: Param in which the user ID is normally stored, if none is provided, then \"user\" is used. For example, if params.id === \"foo\", then the route should have /user/:foo. \n\nInitialization returns the object that has the restrictTo* middleware.\n\n##### Middleware\nAs in the example above, once you have authentication and authorization set up and initialized, you may use authorization middleware:\n\n````JavaScript\n// execute routeHandler() if user is logged in, else send 401\napp.get(\"/some/route/:user\",cansec.restrictToLoggedIn,routeHandler); \n// execute routeHandler if req.param(\"user\") === user[fields.id], where 'user' is as returned by validate(), else send 401\napp.get(\"/my/data/:user\",cansec.restrictToSelf,routeHandler);\n// execute routeHandler if user[fields.roles] contains \"admin\", where 'user' is as returned by validate(), else send 401\napp.get(\"/admin/:user\",cansec.restrictToRoles(\"admin\"),routeHandler);\n// execute routeHandler if one of:\n//     req.param(\"secret\") === \"false\"\n//     req.param(\"secret\") === \"true\" && user[fields.roles] contains \"admin\"\napp.get(\"/user\",cansec.ifParam(\"secret\",\"true\").restrictToRoles(\"admin\"),routeHandler);\n\n````\n\n#### Unauthorized Errors\ncansecurity authorization will directly return a `403` and message `unauthorized` if authorization is required, i.e. a restrictTo* middleware is called, **and** fails. \n\nObviously, authentication comes before authorization, and if the user fails to authenticate, you may get a 401 from the authentication section without ever trying authorization.\n\n#### Middleware API \nThe following authorization middleware methods are available. Each one is followed by an example. There are two sections\n\n* Regular API: Regular restrictTo* that are always applied.\n* Conditional API: Conditions under which to apply the regular restrictTo* interfaces.\n\n##### Regular API\nRegular API interfaces are used to restrict access, each example is given below.\n\n* restrictToLoggedIn - user must have logged in\n\n````JavaScript\napp.get(\"/some/route/:user\",cansec.restrictToLoggedIn,routeHandler);\n````\n\n* restrictToSelf - user must have logged in and the user ID in the user object from authentication (fields.id above) must equal some parameter in the URL or body (params.id)\n\n````JavaScript\nvar cs = require('cansecurity');\ncansec = cs.init({\n\tfields: {id: \"userid\"},\n\tparams: {id: \"user\"}\n});\n// only allow a person to see their own stuff\napp.get(\"/some/route/:user\",cansec.restrictToSelf,routeHandler);\n// note that the param in the route is \":user\", which matches the params.id:\"user\" in cansec.init()\n````\n\n* restrictToRoles - user must have logged in and the user must have in his/her \"roles\" property (fields.roles) in the user object from authentication one of the named roles (one role as string or multiple in array). Roles argument to the function may be a string or an array of strings.\n\n````JavaScript\nvar cansec = require('cansecurity').init({\n\tfields: {id: \"userid\", roles:\"roles\"},\n\tparams: {id: \"user\"}\n});\napp.get(\"/api/admin\",cansec.restrictToRoles(\"admin\"),routeHandler);\napp.get(\"/api/siteadmin\",cansec.restrictToRoles([\"admin\",\"superadmin\"]),routeHandler);\n// will require the User object from authentication to have a property \"roles\", which is an array of strings. If one of the strings is \"admin\", then /api/admin will be allowed. If one of the roles is \"admin\" or \"superadmin\", then /api/siteadmin will be allowed.\n````\n* restrictToSelfOrRoles - combination of the previous two. Roles argument to the function may be a string or an array of strings.\n\n````JavaScript\nvar cansec = require('cansecurity').init({\n\tfields: {id: \"userid\", roles:\"roles\"},\n\tparams: {id: \"user\"}\n});\napp.put(\"/api/user/:user\",cansec.restrictToSelfOrRoles(\"admin\"),routeHandler);\n/*\n * Will work if one of the following is true:\n * 1) The logged in user has a property \"userid\" and it matches exactly the value of the param \":user\"; OR\n * 2) The logged in user has a property \"roles\" which is an array of strings, one of which is \"admin\"\n */\n````\n\n* restrictToParam - user must have logged in and some field in the user object (fields.id) from authentication must equal some parameter in the URL or body (params.id). Param argument to the function may be a string or an array of strings.\n\n````JavaScript\nvar cansec = require('cansecurity').init({\n\tfields: {id: \"userid\", roles:\"roles\"},\n\tparams: {id: \"user\"}\n});\napp.put(\"/api/user/search\",cansec.restrictToParam(\"searchParam\"),routeHandler);\n/*\n * Will work if the logged in user has a property \"userid\" (since init() set fields.id to \"userid\"), and the value of that property matches req.param(\"searchParam\"). \n * Useful for using parameters in searches.\n */\n````\n\t\n* restrictToParamOrRoles - user must have logged in and some field in the user object (fields.id) from authentication must equal some parameter in the URL or body (params.id) *or* user must have a specific role. Param argument and roles argument to the function may each be a string or an array of strings.\n\n````JavaScript\nvar cansec = require('cansecurity').init({\n\tfields: {id: \"userid\", roles:\"roles\"},\n\tparams: {id: \"user\"}\n});\napp.put(\"/api/user/search\",cansec.restrictToParamOrRoles(\"searchParam\",[\"admin\",\"superadmin\"]),routeHandler);\napp.put(\"/api/address/search\",cansec.restrictToParamOrRoles([\"searchParam\",\"addParam\"],\"admin\"),routeHandler);\n/*\n * Will work if one of the following is true:\n * 1) the logged in user has a property \"userid\" (since init() set fields.id to \"userid\"), and the value of that property matches req.param(\"searchParam\"), or, in the second example, one of \"searchParam\" or \"addParam\". \n * 2) The logged in user has the role, as one of the array of strings of the property \"roles\", set to \"admin\" or \"superadmin\" (for the first example), or \"admin\" (for the second example).\n */\n````\n\n* restrictToField - user must have logged in and some field in the user object (fields.id) from authentication must equal the response to a given callback with a given field or fields parameter.\n\n````JavaScript\nvar cansec = require('cansecurity').init({\n\tfields: {id: \"userid\", roles:\"roles\"},\n\tparams: {id: \"user\"}\n});\napp.get(\"/api/user/search\",cansec.restrictToField(\"owner\",getObjectFn),routeHandler);\n/*\n * Will call getObjectFn(req,res) to get a regular JavaScript object, and then try to match the requested fields, in the above example \"owner\", to the ID of the User from authentication. The ID from authentication is user.userid, as given in the init() for fields.id.\n */\n````\n\n* restrictToFieldOrRoles - user must have logged in and some field in the user object (fields.id) from authentication must equal the response to a given callback with a given field or fields parameter, *or* the user must have a role or roles.\n\n````JavaScript\nvar cansec = require('cansecurity').init({\n\tfields: {id: \"userid\", roles:\"roles\"},\n\tparams: {id: \"user\"}\n});\napp.get(\"/api/user/search\",cansec.restrictToFieldOrRoles(\"owner\",\"admin\",getObjectFn),routeHandler);\n/*\n* Will call getObjectFn(req,res) to get a regular JavaScript object, and then try to match the requested fields, in the above example \"owner\", to the ID of the User from authentication. The ID from authentication is user.userid, as given in the init() for fields.id.\n */\napp.get(\"/api/user/search\",cansec.restrictToFieldOrRoles([\"owner\",\"recipient\"],[\"admin\",\"superadmin\"],getOwnerFn),routeHandler);\n````\n\nA typical use case for restrictToField and its variant restrictToFieldOrRoles is that you may load an object, and want to restrict its access to the owner of an object. For example, let us assume that you are loading an employee record. For that, restrictToSelf would be fine, since the User ID from authentication is likely to match the ID for requesting the employee record. The following example shows this use case:\n\n````JavaScript\nvar cansec = require('cansecurity').init({\n\tfields: {id: \"userid\", roles:\"roles\"},\n\tparams: {id: \"user\"}\n});\napp.get(\"/api/employee/:user\",cansec.restrictToSelfOrRoles(\"admin\"),sendDataFn);\n````\n\nHowever, what if you are retrieving a record whose authorization requirements are not known until it is loaded. For example, you are loading a paystub, whose URL is /api/paystubs/34567. Until you load the paystub, you don't actually know who the owner is. Of course, you might make it accessible only via a more detailed API as /api/employee/12345/paystubs/34567, but let us assume that you need to do it directly, with the first simplified API. Until you load the actual paystubs object, and see that the employee is, indeed, 12345, the one who logged in, you don't know whether or not to show it. The following example describes how to simply implement this use case:\n\n````JavaScript\nvar cansec = require('cansecurity').init({\n\tfields: {id: \"userid\", roles:\"roles\"},\n\tparams: {id: \"user\"}\n});\napp.get(\"/api/employee/:user\",cansec.restrictToSelfOrRoles(\"admin\"),sendDataFn);\napp.get(\"/api/paystub/:payid\",payStubLoad,cansec.restrictToField(\"employee\",getObjectFn),sendDataFn);\n````\n\nIn this example, we load the paystub, but do not send it. The paystub object retrieved by payStubLoad looks like this:\n\n````JavaScript\n{\n\tid: \"34567\",\n\temployee: \"12345\",\n\tdate: \"2011-01-31\",\n\tamount: \"$100\"\n}\n````\nThis is then stored in the request object. Now getObjectFn can return the same object, which has employee as \"12345\". This is then matched to User.userid, which will allow it to proceed.\n\n##### Conditional API\n\nThe conditional API simply creates conditions under which the regular restrictions are applied. If the conditions are not met, then restrictions are not applied.\n\n* ifParam - apply the restriction only if a certain parameter matches a certain value.\n\nWhat if you have a resource that is normally accessible by all, but if certain parameters are applied, e.g. ?secret=true, then it should be restricted to an admin?\n\n````JavaScript\napp.get(\"/api/employee\",cansec.ifParameter(\"secret\",\"true\").restrictToRoles(\"admin\"),sendDataFn);\n````\n\nIn the above example, anyone can do a GET on /api/employee, but if they pass the parameter ?secret=true, then they will have to be logged in and have the role \"admin\" defined. \n\nIn our example, sendDataFn also checks for that parameter. If it is not set, then it sends public data about the employee list; if it is set, it sends public and private data, trusting that cansecurity prevented someone from getting in with ?secret=true unless they are authorized.\n\n\n#### Why We Need a \"get\" Function for restrictToField\nA common pattern, as shown in the last example above, is to retrieve an object, check it against the user, and then determine whether or not to allow the request to proceed. cansecurity would *love* to be able to just do the check directly. It even knows which field/property to check: \"employee\". It has two problems, however:\n\n1. It doesn't know where the object is stored. Sure, most use cases store it in the request object somewhere, or possibly the response object, but cansecurity does not want to impose on your application where that is. Thus, it just delegates to you, saying, \"give me a function to retrieve the object, if I pass you the request.\"\n2. It doesn't know what the object looks like. It may be a POJSO (Plain Old JavaScript Object), like above, or one that supports that style, like Spine Models. But what if it is something more complex, a function, with special parameters? What if it is a Backbone Model, which requires using getters? By asking your application to provide a function, it completely abstracts out the issue, and says, \"whatever, as long as you pass me back a POJSO, I am happy.\"\n\n### Declarative Authorization\nDeclarative authorization is given to drastically clean up your authorizations. Normal cansecurity authorization lets you inject authorization into every route, like so.\n\n````JavaScript\napp.get(\"/secure/loggedin\",cansec.restrictToLoggedIn,send200);\napp.get(\"/secure/user/:user\",cansec.restrictToSelf,send200);\napp.get(\"/secure/roles/admin\",cansec.restrictToRoles(\"admin\"),send200);\napp.get(\"/secure/roles/adminOrSuper\",cansec.restrictToRoles([\"admin\",\"super\"]),send200);\napp.get(\"/secure/selfOrRoles/:user/admin\",cansec.restrictToSelfOrRoles(\"admin\"),send200);\napp.get(\"/secure/selfOrRoles/:user/adminOrSuper\",cansec.restrictToSelfOrRoles([\"admin\",\"super\"]),send200);\n\n// only authorized if \"searchParam\" is set to the same value as the user ID field set in cs.init();\napp.get(\"/secure/param\",cansec.restrictToParam(\"searchParam\"),send200);\napp.get(\"/secure/paramOrRole\",cansec.restrictToParamOrRoles(\"searchParam\",\"admin\"),send200);\napp.get(\"/secure/paramOrMultipleRoles\",cansec.restrictToParamOrRoles(\"searchParam\",[\"admin\",\"super\"]),send200);\n\n// only authorized if getCheckObject() returns an object, with field owner, that has a value matching the user ID field\napp.get(\"/secure/field\",cansec.restrictToField(\"owner\",getCheckObject),send200);\napp.get(\"/secure/fields\",cansec.restrictToField([\"owner\",\"recipient\"],getCheckObject),send200);\napp.get(\"/secure/fieldOrRole\",cansec.restrictToFieldOrRoles(\"owner\",\"admin\",getCheckObject),send200);\napp.get(\"/secure/fieldOrRoles\",cansec.restrictToFieldOrRoles(\"owner\",[\"admin\",\"super\"],getCheckObject),send200);\napp.get(\"/secure/fieldsOrRole\",cansec.restrictToFieldOrRoles([\"owner\",\"recipient\"],\"admin\",getCheckObject),send200);\napp.get(\"/secure/fieldsOrRoles\",cansec.restrictToFieldOrRoles([\"owner\",\"recipient\"],[\"admin\",\"super\"],getCheckObject),send200);\n\n// only authorized if the request parameter \"private\" has the value \"true\", and then restrict to logged in\napp.get(\"/secure/conditionalDirect\",cansec.ifParam(\"private\",\"true\").restrictToLoggedIn,send200);\napp.get(\"/secure/conditionalIndirect\",cansec.ifParam(\"private\",\"true\").restrictToRoles([\"admin\",\"super\"]),send200);\n````\n\nThis is worlds better than before, when authorization was one of:\n\n* didn't exist\n* stuck *inside* the routes (really bad for separation of concerns, leading to unmaintainable code)\n* binary, logged in or out but nothing more fine-tuned than that\n\nBut it still requires lots of code in the routes. What if you could just declare in a config file what authorization rules you want?\n\n````JavaScript\n{\n\t\"routes\": [\n\t  // [verb,path,[test params,][require logged in],[loader,]test condition]\n\t\t[\"GET\",\"/api/user\",true,\"user.roles.admin === true\"],\n\t\t[\"GET\",\"/api/user/:user\",\"user.roles.admin === true || user.id === req.param('user')\"],\n\t\t[\"GET\",\"/api/user/:user\",{\"private\":\"true\"},true,\"user.roles.admin === true || user.id === req.param('user')\"],\n\t\t[\"PUT\",\"/api/user/:user\",\"user.roles.admin === true || user.id === req.param('user')\"],\n\t\t[\"GET\",\"/api/user/:user/roles\",\"user.roles.admin === true || user.id === req.param('user')\"],\n\t\t[\"PUT\",\"/api/user/:user/roles\",\"user.roles.admin === true\"]\n\t]\t\n}\n````\n\ncansecurity provides you precisely this ability!\n\n#### Usage\nTo use declarative authorization, you take two steps:\n\n1. Set up the config file\n2. `app.use(cansec.authorizer(pathToConfigFile,options))`\n\n#### Config File\nThe config file is a simple `json` file. You can name it whatever you want. The file should be a single object, with one key, `routes`, which is an array of arrays.\n\n````JavaScript\n{\n\troutes:[\n\t  [/* route 1 */],\n\t  [/* route 2 */],\n\t\t/* ... */\n\t  [/* route n */]\n\t]\n}\n````\n\nEach route is an array of 4 or 5 parts, as follows:\n\n    [verb,route,[params,][loggedIn,][loader,]condition]\n\n* verb: string, one of GET PUT POST DELETE, and is case-insensitive\n* route: string, an express-js compatible route, e.g. \"/api/user/:user\" or \"/post/:post/comment/:comment\". Note that \".:format?\" is optional. See \"format\" later.\n* params: optional object, which will be checked to match the route, e.g. `{private:true}` or `{secret:\"true\",name:\"foo\"}`. If the params match, then the route will be applied, else this route is considered to *not* match and will be ignored. See the examples below and the tests.\n* loggedIn: optional boolean. If true, user **must** be logged in via cansecurity **before** checking authorization. If the user is not logged in, send `401`.\n* loader: name of a loader in your initializer that should run when the verb/route/params/loggedIn are matched, but before testing the condition\n* condition: JavaScript string which should return a condition. If true, then do the opposite of the default behaviour\n\nHere are some examples.\n\n````JavaScript\n// when GET /api/user, send 403 unless user.roles.admin === true\n[\"GET\",\"/api/user\",\"user.roles.admin === true\"],\n\n// when GET /api/user, if not logged in, send 401; if logged in send 403 unless user.roles.admin === true\n[\"GET\",\"/api/user\",true,\"user.roles.admin === true\"],\n\n// when GET /api/user/:user, send 403 unless user.roles.admin === true, OR user.id === req.param('user')\n[\"GET\",\"/api/user/:user\",\"user.roles.admin === true || user.id === req.param('user')\"],\n\n// when GET /api/user/:user AND ?private=true (or in the body), send 403 unless user.roles.admin === true || user.id === req.param('user')\n//     if private !== true (or is unset or anything else), then this rule is not applied, and access is allowed\n[\"GET\",\"/api/user/:user\",{\"private\":\"true\"},\"user.roles.admin === true || user.id === req.param('user')\"],\n\n// same as previous example, but send 401 if !logged in, then continue from previous example\n[\"GET\",\"/api/user/:user\",{\"private\":\"true\"},true,\"user.roles.admin === true || user.id === req.param('user')\"],\n\n// when PUT /api/user/:user, send 403 unless user.roles.admin === true || user.id === req.param('user')\n[\"PUT\",\"/api/user/:user\",\"user.roles.admin === true || user.id === req.param('user')\"],\n\n// when GET /api/user/:user/roles, send 403 unless user.roles.admin === true || user.id === req.param('user')\n[\"GET\",\"/api/user/:user/roles\",\"user.roles.admin === true || user.id === req.param('user')\"],\n\n// when PUT /api/user/:user/roles, send 403 unless user.roles.admin === true\n[\"PUT\",\"/api/user/:user/roles\",\"user.roles.admin === true\"]\n\n// when PUT /api/user/:user/roles, run the \"roles\" loader, then send 403 unless user.roles.admin === true || item.name === 'me'\n[\"PUT\",\"/api/user/:user/roles\",\"roles\",\"(user.roles.admin === true) || (item.name === 'me')\"]\n````\n\n#### Context for the Condition\nThe condition string is run inside its own new context. Besides the usual nodejs environment, it has the following variable available to it:\n\n1. `req`: the actual express `req` object, normally found on each route whose signature is `function(req,res,next)`. \n2. `request`: an alias for `req`\n3. `user`: the user object if you used cansecurity authentication. This is the equivalent of calling `cansec.getUser(req)`.\n4. `_`: the underscore/lodash utility functions. cansecurity actually uses [lodash](http://lodash.com)\n5. `item`: the item loaded, if any, by the loader functions passed to `cansec.init()`; see below.\n\n#### Loading Data\nYou have the option, but not the requirement, to load data before passing your route through the declarative authorizer. \n\nThe data is loaded by passing a loader to `cansec.init()`:\n\n````JavaScript\ncansec.init({\n\tloader:  {\n\t\tuser: function(req,res,next) {\n\t\t},\n\t\tgroup: function(req,res,next) {\n\t\t}\n\t}\n});\n````\n\nEach loader function has two simple jobs to do:\n\n1. Load relevant data into `req.cansecurity.item`\n2. Call `next`\n\n`req.cansecurity` will already be available as an object. `item` can be an object, a string, an array, null, undefined, boolean, or anything at all that you want to pass to your conditions.\n\nThe full suite of `request`, `response` and `next` methods is available. Thus, you could easily call `res.send(400)` if you have an error and do not wish to proceed, or perhaps `next(error)`. Similarly, `req.param(someParam)` is also available.\n\nHere is an example:\n\n````JavaScript\ncansec.init({\n\tloader: {\n\t\tgroup: function(req,res,next) {\n\t\t\tmodels.group.find(someParam,function(err,data){\n\t\t\t\treq.cansecurity.item = data;\n\t\t\t\tnext();\n\t\t\t});\n\t\t}\n\t}\n});\n````\n\nAnd the declarative:\n\n````JavaScript\n{\n\troutes: [\n\t\t[\"GET\",\"/api/group/:group\",true,\"group\",\"_.contains(item.members,user.id)\"]\n\t]\n}\n````\n\n\n**Note:** Any route where login is required, login will be validated *before* running the loader.\n\n\n\n#### What It Returns\nThe authorizer has one of three possible results:\n\n* Send `401` if authentication is required and the user is not logged in\n* Send `403` if the route matches the condition fails\n* `next()`\n\nThe logic is as follows:\n\n1. Does the route match? If not, `next()`; else\n2. Does the route require authentication? If yes and the user is not logged in, send `401`; else\n3. Does the condition evaluate to `true` and not have any errors? If not, send `403`; else\n4. `next()`\n\n\n#### Use the authorizer\nSimple:\n\n    app.use(cansec.authorizer(pathToConfigFile,options));\n\t\tapp.use(app.router);\n\t\t\nDone!\n\n\n#### Path Format\nMany REST paths use a \"format\" extension. In express, it usually looks like this:\n\n````JavaScript\napp.get(\"/api/user/:user.:format?\",fn);\n````\n\nThis allows express to handle both `/api/user/10` and `/api/user/10.json`.\n\ncansecurity's declarative authorization *can* handle `.:format?` just by putting it in the path:\n\n    [\"GET\",\"/api/user/:user.:format?\",{\"private\":\"true\"},true,\"user.roles.admin === true || user.id === req.param('user')\"],\n\n\nBut that can get tedious, if you have a lot of routes. To simplify things, one of the options when setting it up is `{format:true}` as follows:\n\n````JavaScript\napp.use(cansec.authorizer(pathToConfigFile,{format:true}));\n````\n\nIf `format` is set to `true`, then cansecurity will *automatically* add `.:format?` to every path that does not end in `.:format?` already, or in `/`.\n\n\n## Testing\nTo run the tests, from the root directory, run `npm test`.\n\n## Breaking Changes\n\n#### Changes to version 0.6.4\nDeclarative authorization no longer has an option to \"allow\" or \"deny\" by default. **All** rules are \"deny\" unless the condition passes. It is very easy to invert the condition and make it pass except in certain circumstances.\n\n    [\"GET\",\"/secure/path\",true,\"allow\",\"a === b\"]\n\t\t\nCan just as easily be written as\n\n    [\"GET\",\"/secure/path\",true,\"deny\",\"a !== b\"]\n\nOr more simply\n\n    [\"GET\",\"/secure/path\",true,\"a !== b\"]\n\n\n#### Changes to version 0.6.0\nPrior to version 0.6.0, cansecurity *sometimes* would send back a 401 or 403 as `res.send(401,\"unauthenticated\")` or `res.send(403,\"unauthorized\")`, and sometimes would just call `next({status:401,message:\"unauthenticated\"})` or `next({status:403,message:\"unauthorized\"})`.\n\nBeginnign with version 0.6.0, cansecurity will **always** return 401 if authentication is required and not present / fails, and will **always** return a 403 if authorization is required and fails.\n\nThis makes the results far more consistent.\n\n#### Changes to version 0.5.0\nThese notes apply to anyone using cansecurity *prior* to v0.5.0. These changes may be breaking, so read carefully. \n\n##### express 3.x required\nPrior to version 0.5.0 (and preferably prior to 0.4.8), cansecurity worked with express 2.x and 3.x, although the full testing regimen worked properly only in express 2.x. Beginning with 0.5.0, only express 3.x will work.\n\n##### validatePassword and getUser consolidated into \nIn versions of cansecurity prior to 0.5.0, there were two functions passed to `init()`:\n\n* `validatePassword()` was called when the user authenticated with credentials to be checked.\n* `getUser()` was called when the user was authenticated *already* using a token or session, and we just needed the user object.\n\nAs of version 0.5.0, these are consolidated into a single `validate()` function. Please check the documentation below.\n\nUntil version 1.0 of cansecurity, the legacy functions will continue to operate, if deprecated, under the following circumstances:\n\n    IF `validate()` is `undefined`, AND (`validatePassword()` and `getUser()`) are present, THEN cansecurity will use the old API. \n\n\t\tIF `validate()` is defined, THEN (`validatePassword()` and `getUser()`) will be ignored, whether present or not.\n\nBeginning with cansecurity 1.0, the old API will not function at all.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/deitch/cansecurity/issues"
  },
  "homepage": "https://github.com/deitch/cansecurity",
  "_id": "cansecurity@0.6.10",
  "_from": "cansecurity@>=0.6.10"
}
